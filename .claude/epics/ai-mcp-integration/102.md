---
name: E2E testing + error handling + graceful fallback
status: open
created: 2026-02-26T16:12:18Z
updated: 2026-02-26T16:22:04Z
github: https://github.com/WOOWTECH/odoo-addon-woow-paas-platform/issues/102
depends_on: [98, 100]
parallel: false
conflicts_with: []
---

# Task: E2E testing + error handling + graceful fallback

## Description

端到端測試整個 MCP tool calling 流程，強化 error handling 和 graceful fallback。確保 MCP 連線失敗、tool 執行失敗、timeout 等異常情境都被正確處理，不影響正常對話功能。

## Acceptance Criteria

- [ ] MCP Server 連線失敗時：AI 降級為純文字對話 + 顯示「工具暫時不可用」提示
- [ ] Tool 執行 timeout（30 秒）時：AI 收到 timeout error 並在回覆中說明
- [ ] Tool calling loop 超過 5 次時：自動停止並生成最終回覆
- [ ] MCP Server URL 不可達時：`action_test_connection()` 正確更新 state=error
- [ ] 前端 tool call block 顯示 error 狀態（紅色 badge + error message）
- [ ] 所有 error paths 有 logging（`_logger.warning/error`）
- [ ] 端到端測試：Admin 設定 MCP server → AI 對話中使用 tool → 結果正確顯示
- [ ] 端到端測試：User 設定 MCP server on Cloud Service → 對話中使用 → 結果正確
- [ ] 向後相容：無 MCP 設定的 assistant 行為完全不變

## Technical Details

### 測試方案

由於需要真實 MCP Server 進行 E2E 測試，可使用：

1. **Test MCP Server**：建立一個簡單的 FastAPI MCP server（放在 `extra/` 下），提供 1-2 個測試 tools（如 `echo`, `get_time`）
2. **Manual E2E**：在 Docker 環境中部署 test server + 設定 MCP → 對話測試

### Error Handling 強化

```python
# ai_client.py - 強化 error handling
async def _async_agent_invoke(self, messages, mcp_tools):
    try:
        server_config = self._build_mcp_client_config(mcp_tools)
        async with MultiServerMCPClient(server_config) as client:
            tools = await client.get_tools()
            ...
    except asyncio.TimeoutError:
        _logger.warning("MCP tool calling timeout")
        return self.chat_completion(messages)  # Fallback
    except ConnectionError as e:
        _logger.warning(f"MCP connection failed: {e}")
        return self.chat_completion(messages)  # Fallback
    except Exception as e:
        _logger.error(f"MCP tool calling error: {e}")
        return self.chat_completion(messages)  # Fallback
```

### Frontend Error States

```javascript
// AiChat.js
updateToolResult(toolName, result, error = null) {
    const tc = this.currentToolCalls.find(t => t.tool === toolName);
    if (tc) {
        tc.result = result;
        tc.error = error;
        tc.loading = false;
    }
}
```

```xml
<!-- Tool call error state -->
<div t-if="tc.error" class="o_woow_tool_call__error">
    <span class="material-symbols-outlined">error</span>
    <span t-esc="tc.error"/>
</div>
```

### 測試 Checklist

| Scenario | Expected Behavior |
|----------|-------------------|
| MCP server online, tool succeeds | Tool call + result 正常顯示 |
| MCP server offline | 降級純文字，log warning |
| Tool execution fails | AI 回覆含 error 說明 |
| Tool execution timeout | AI 回覆含 timeout 說明 |
| Loop exceeds 5 iterations | 自動停止 + 最終回覆 |
| No MCP servers configured | 正常純文字對話 |
| User MCP + system MCP 合併 | 兩者的 tools 都可用 |
| User MCP on wrong cloud service | Tool 不出現 |

## Dependencies

- [ ] Task #98 完成（前端 tool call UI 存在）
- [ ] Task #100 完成（user MCP 完成）

## Effort Estimate

- Size: M
- Hours: 6-8
- Parallel: false（最後收尾 task）

## Definition of Done

- [ ] 所有 error scenarios 都有 graceful handling
- [ ] E2E 端到端流程驗證通過
- [ ] 向後相容驗證通過（無 MCP 設定）
- [ ] Error logging 完善
- [ ] 前端 error 狀態顯示正確
