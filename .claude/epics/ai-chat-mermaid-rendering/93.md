---
name: AiChat Mermaid 渲染整合
status: open
created: 2026-02-26T07:11:01Z
updated: 2026-02-26T07:19:39Z
github: https://github.com/WOOWTECH/odoo-addon-woow-paas-platform/issues/93
depends_on: [91, 92]
parallel: false
conflicts_with: []
---

# Task: AiChat Mermaid 渲染整合

## Description

在 `AiChat.js` 中整合 mermaid 渲染觸發邏輯：使用 OWL `onPatched` lifecycle hook 在 DOM 更新後掃描並渲染 mermaid 容器，同時在 SSE 串流中偵測未關閉的 mermaid block 並顯示 placeholder。

## Acceptance Criteria

- [ ] 歷史訊息中的 mermaid block 在頁面載入後自動渲染為 SVG
- [ ] 新收到的 AI 訊息（SSE 完成後）中的 mermaid block 自動渲染
- [ ] SSE 串流中，未關閉的 mermaid block 顯示為 code block + loading 提示（如「圖表渲染中...」）
- [ ] SSE 串流中，已關閉的 mermaid block 在串流階段先顯示為 code block，串流結束後觸發渲染
- [ ] 已渲染的 mermaid 容器（`data-processed`）不會被重複渲染
- [ ] `onPatched` hook 不會導致效能問題（使用 requestAnimationFrame 或 debounce）

## Technical Details

### 修改檔案

`src/static/src/paas/components/ai-chat/AiChat.js`

### 1. Import mermaid_loader

```javascript
import { renderMermaidBlocks } from "../../services/mermaid_loader";
```

### 2. onPatched Hook

```javascript
setup() {
    // ... 現有 setup 邏輯

    onPatched(() => {
        this._renderMermaidInMessages();
    });
}

/**
 * 掃描訊息區域中的 mermaid 容器並觸發渲染。
 * 使用 requestAnimationFrame 避免阻塞。
 */
_renderMermaidInMessages() {
    const messageList = this.messageListRef.el;
    if (!messageList) return;

    // 只有存在未處理的 mermaid block 時才觸發
    const pending = messageList.querySelectorAll(".o_woow_mermaid:not([data-processed])");
    if (pending.length === 0) return;

    requestAnimationFrame(() => {
        renderMermaidBlocks(messageList);
    });
}
```

### 3. SSE 串流中的 Mermaid Block 偵測

修改 `streamingHtml` getter：

```javascript
get streamingHtml() {
    let text = this.state.streamingText;

    // 偵測未關閉的 mermaid block
    // 找出所有 ```mermaid 和對應的 ``` 結束標記
    // 如果最後一個 mermaid block 未關閉，替換為 placeholder
    text = this._handleStreamingMermaidBlocks(text);

    return parseMarkdown(text);
}

/**
 * 處理串流文字中未關閉的 mermaid block。
 * 已關閉的 block 保持原樣（交給 parseMarkdown 處理）。
 * 未關閉的 block 替換為 placeholder 提示。
 */
_handleStreamingMermaidBlocks(text) {
    // 使用正則找出所有 ```mermaid 開始標記的位置
    const openPattern = /```mermaid
/g;
    const closePattern = /```/g;
    // ... 追蹤開/關狀態
    // 如果有未關閉的 block：
    // 將該 block 替換為 ```
[圖表載入中...]
```
    return processedText;
}
```

### 4. loadHistory 後觸發渲染

`loadHistory()` 完成後，`onPatched` hook 會自動觸發（因為 state.messages 變更導致 DOM 更新），不需要額外處理。

### 5. 串流結束後觸發渲染

`_createAiMessage()` 生成完整訊息後，`onPatched` 同樣會自動觸發。不需要額外處理。

### 關鍵考量

- `onPatched` 在每次 DOM 更新都會觸發，但 `querySelectorAll` + `data-processed` 檢查使得無 mermaid 時幾乎零成本
- 串流期間每個 chunk 都會觸發 `streamingHtml` 重新計算，但 mermaid block 偵測是輕量正則操作
- 串流中的 mermaid block 不應該在串流階段渲染（不完整），等串流結束 `_createAiMessage()` 後再渲染

## Dependencies

- [ ] Task #91 完成（mermaid_loader.js 的 `renderMermaidBlocks` 方法可用）
- [ ] Task #92 完成（parseMarkdown 輸出正確的 `.o_woow_mermaid` 容器）

## Effort Estimate

- Size: M
- Hours: 3-4
- Parallel: false（依賴 Task #91 和 002）

## Definition of Done

- [ ] 歷史訊息中的 mermaid 自動渲染為 SVG 圖表
- [ ] SSE 串流中未完成的 mermaid block 顯示 placeholder
- [ ] SSE 串流結束後 mermaid 自動渲染
- [ ] 不會重複渲染已處理的 mermaid 容器
- [ ] 無 mermaid 內容時不影響既有功能和效能
